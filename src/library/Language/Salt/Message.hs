-- Copyright (c) 2013 Eric McCorkle.
--
-- This program is free software; you can redistribute it and/or
-- modify it under the terms of the GNU General Public License as
-- published by the Free Software Foundation; either version 2 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful, but
-- WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-- 02110-1301 USA

{-# OPTIONS_GHC -funbox-strict-fields -Wall -Werror #-}
{-# LANGUAGE FlexibleContexts #-}

-- | A module containing
module Language.Salt.Message(
       Message,
       badChars,
       untermComment,
       untermString,
       hardTabs,
       trailingWhitespace,
       newlineInString
       ) where

import Control.Monad.Messages
import Data.Hashable
import Data.Position
--import Data.Symbol
--import Language.Salt.Core.Syntax

import qualified Data.ByteString.Lazy as Lazy
import qualified Data.ByteString.Lazy.UTF8 as Lazy
--import qualified Data.ByteString.UTF8 as Strict
import qualified Data.Message as Msg

-- | A representation of proof errors that can be generated by a proof
-- checker.
data Message =
    -- | Bad characters in lexical input.
    BadChars {
      -- | The bad characters from input (error).
      badCharsContent :: !Lazy.ByteString,
      -- | The position of the bad characters.
      badCharsPos :: !Position
    }
    -- | Unterminated comment (error).
  | UntermComment {
      untermCommentPos :: !Position
    }
    -- | Unterminated string literal (error).
  | UntermString {
      untermStringPos :: !Position
    }
    -- | Hard tabs in input (remark).
  | HardTabs {
      hardTabsPos :: !Position
    }
  | TrailingWhitespace {
      trailingWhitespacePos :: !Position
    }
  | NewlineInString {
      newlineInStringPos :: !Position
    }
{-
  -- | An error message representing an undefined proposition in the
  -- truth envirnoment.
    UndefProp {
      -- | The name of the undefined proposition.
      undefName :: !Symbol,
      -- | The position at which the bad use of "exact" occurred.
      undefPos :: !Position
    }
  -- | An error message representing an attempt to use the "exact"
  -- rule with a proposition that does not match the goal.
  | ApplyMismatch {
      -- | The name of the mismatched proposition in the truth environment.
      applyName :: !Symbol,
      -- | The proposition from the truth environment.
      applyProp :: Term Symbol Symbol,
      -- | The goal proposition.
      applyGoal :: Term Symbol Symbol,
      -- | The position at which the bad use of "exact" occurred.
      applyPos :: !Position
    }
  -- | An error message representing an attempt to use the "intro"
  -- rule with a goal that is not an implies proposition.
  | IntroMismatch {
      -- | The goal proposition.
      introGoal :: Term Symbol Symbol,
      -- | The position at which the bad use of "exact" occurred.
      introPos :: !Position
    }
  -- | An error message representing an attempt to use the "introVar"
  -- rule with a goal that is not a forall proposition.
  | IntroVarMismatch {
      -- | The goal proposition.
      introVarGoal :: Term Symbol Symbol,
      -- | The position at which the bad use of "exact" occurred.
      introVarPos :: !Position
    }
  -- | An error message representing an attempt to use the "apply"
  -- rule with a proposition that is not a forall proposition.
  | ApplyWithMismatch {
      -- | The proposition attempting to be applied.
      applyWithProp :: Term Symbol Symbol,
      -- | The position at which the bad use of "apply" occurred.
      applyWithPos :: !Position
    }
  -- | An error message indicating that a proof script continues after
  -- the proof is complete.
  | Complete {
      -- | The position at which the bad use of "apply" occurred.
      completePos :: !Position
    }
  -- | An error message indicating that a proof script ended before
  -- the proof was complete.
  | Incomplete
-}
    deriving (Ord, Eq)

instance Hashable Message where
  hashWithSalt s BadChars { badCharsContent = str, badCharsPos = pos } =
    s `hashWithSalt` (0 :: Int) `hashWithSalt` str `hashWithSalt` pos
  hashWithSalt s UntermComment { untermCommentPos = pos } =
    s `hashWithSalt` (1 :: Int) `hashWithSalt` pos
  hashWithSalt s UntermString { untermStringPos = pos } =
    s `hashWithSalt` (2 :: Int) `hashWithSalt` pos
  hashWithSalt s HardTabs { hardTabsPos = pos } =
    s `hashWithSalt` (3 :: Int) `hashWithSalt` pos
  hashWithSalt s TrailingWhitespace { trailingWhitespacePos = pos } =
    s `hashWithSalt` (4 :: Int) `hashWithSalt` pos
  hashWithSalt s NewlineInString { newlineInStringPos = pos } =
    s `hashWithSalt` (5 :: Int) `hashWithSalt` pos

instance Msg.Message Message where
  severity BadChars {} = Msg.Error
  severity UntermComment {} = Msg.Error
  severity UntermString {} = Msg.Error
  severity HardTabs {} = Msg.Warning
  severity TrailingWhitespace {} = Msg.Warning
  severity NewlineInString {} = Msg.Warning

  position BadChars { badCharsPos = pos } = Just pos
  position UntermComment { untermCommentPos = pos } = Just pos
  position UntermString { untermStringPos = pos } = Just pos
  position HardTabs { hardTabsPos = pos } = Just pos
  position TrailingWhitespace { trailingWhitespacePos = pos } = Just pos
  position NewlineInString { newlineInStringPos = pos } = Just pos

  brief BadChars {} = Lazy.fromString "Invalid characters in input"
  brief UntermComment {} = Lazy.fromString "Unterminated comment"
  brief UntermString {} = Lazy.fromString "Unterminated string literal"
  brief HardTabs {} = Lazy.fromString "Hard tabs are discouraged"
  brief TrailingWhitespace {} = Lazy.fromString "Trailing whitespace"
  brief NewlineInString {} =
    Lazy.fromString "Unescaped newline in string literal"

  details BadChars {} = Lazy.empty
  details UntermComment {} = Lazy.empty
  details UntermString {} = Lazy.empty
  details HardTabs {} = Lazy.empty
  details TrailingWhitespace {} = Lazy.empty
  details NewlineInString {} = Lazy.empty

  highlighting HardTabs {} = Msg.Background
  highlighting TrailingWhitespace {} = Msg.Background
  highlighting NewlineInString {} = Msg.Background
  highlighting _ = Msg.Foreground

-- | Report bad characters in lexer input.
badChars :: MonadMessages Message m =>
            Lazy.ByteString
         -- ^ The bad characters.
         -> Position
         -- ^ The position at which the bad characters occur.
         -> m ()
badChars str pos = message BadChars { badCharsContent = str, badCharsPos = pos }

-- | Report an unterminated comment in lexer input.
untermComment :: MonadMessages Message m =>
            Position
         -- ^ The position at which the hard tabs occur.
         -> m ()
untermComment pos = message UntermComment { untermCommentPos = pos }

-- | Report an unterminated comment in lexer input.
untermString :: MonadMessages Message m =>
            Position
         -- ^ The position at which the hard tabs occur.
         -> m ()
untermString pos = message UntermString { untermStringPos = pos }

-- | Report hard tabs in lexer input.
hardTabs :: MonadMessages Message m =>
            Position
         -- ^ The position at which the hard tabs occur.
         -> m ()
hardTabs pos = message HardTabs { hardTabsPos = pos }

-- | Report trailing whitespace in lexer input.
trailingWhitespace :: MonadMessages Message m =>
            Position
         -- ^ The position at which the hard tabs occur.
         -> m ()
trailingWhitespace pos =
  message TrailingWhitespace { trailingWhitespacePos = pos }

-- | Report hard tabs in lexer input.
newlineInString :: MonadMessages Message m =>
            Position
         -- ^ The position at which the hard tabs occur.
         -> m ()
newlineInString pos = message NewlineInString { newlineInStringPos = pos }
